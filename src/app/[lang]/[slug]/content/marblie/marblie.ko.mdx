---
title: "마블리, 구슬 런 게임"
date: "2025-06-06"
slug: "marblie"
---

**Marblie**는 **Three.js**와 **Rapier**로 만든 브라우저 기반 구슬 트랙 게임입니다. 사용자가 직접 트랙을 만들고, 구슬을 떨어뜨려 실시간 물리 시뮬레이션을 통해 구르고 튀고 날아다니는 구슬을 보며 시간을 떼울 수 있습니다.

이 프로젝트는 3D 씬을 편집하는 UI/UX 시스템을 어떻게 설계하고 개발할 수 있을지 탐구하기 위해 디자인하고 개발하였습니다. 도시 건설, 시뮬레이션 게임을 어릴 때부터 좋아했고, 3D CAD 도구를 다뤄본 경험과 결합해 그런 즐거움들을 제 방식으로 제작한 프로젝트입니다.

누구나 편하게 즐길 수 있도록 제작하였습니다. 저도 종종 브라우저 탭 하나에 띄워두고 잠깐씩 만지작거리며 딴짓하곤 합니다.

[Three.js의 X(구 트위터) 공식 계정](https://x.com/threejs/status/1922982953887400246)에 소개되기도 했는데, 저에겐 정말 영광이었고 큰 동기부여가 되었습니다.

<figure>
  <img src="/marblie/marblie-main.jpg" alt="마블리 스크린샷" />
  <figcaption>마블리 스크린샷</figcaption>
</figure>

## 주요 기능

- 트랙 커스터마이징 기능
- 실시간 물리 시뮬레이션
- 트랙과의 상호작용 애니메이션

## 기술 스택

- 렌더링: **Three.js**
- 물리 시뮬레이션: **Rapier**

## 개발 과정

1. **Three.js와 Rapier 통합**

   간단한 직선 트랙과 구슬로 시작해서, Rapier를 사용해 물리 위치를 계산하고 Three.js로 렌더링 위치를 동기화했습니다.

2. **커스텀 트랙 편집 컨트롤**

   `THREE.TransformControls`처럼 트랙을 이동, 회전, 스케일할 수 있는 툴이 필요했습니다. 다양한 트랙 타입에 따라 다르게 작동해야 했기 때문에, 소스 코드를 참고해 직접 컨트롤을 구현했습니다.

3. **HTML 요소를 활용한 트랙 추가 기능**

   클릭과 터치 이벤트를 조정해 사용자 경험을 다듬었습니다. HTML 요소를 클릭하면 트랙이 포인터에 붙고, 다른 위치를 클릭하면 해당 위치에 배치됩니다. 또는 요소를 드래그해서 직접 놓을 수도 있습니다. 두 방식을 모두 활용하여 데스크톱과 모바일 모두에서 사용성이 좋습니다.

4. **곡선, 풍차, 깔때기 등 다양한 트랙 추가**

   각각 물리 시뮬레이션 방식이 다른 트랙도 다양하게 구현해 보았습니다.

5. **야간 모드, 타이머, 카메라 추적 등의 추가 기능 구현**

## 물리 객체

### 구슬

일부 구슬은 광원 역할을 합니다. 중심에 `THREE.PointLight`를 배치하고, 재질에 발광(emissive) 값을 주어 빛나는 느낌을 더했습니다. 어두운 모드에서 특히 더 예쁘게 보이고 랜덤성도 추가되어 재미를 줍니다.

하지만 `THREE.Scene` 에 많은 광원이 실시간으로 추가/제거하는 것에 성능의 문제가 있었습니다. 그래서 미리 사용할 만큼의 `PointLight`를 장면에 배치해두고, 기본 밝기를 0으로 설정했습니다. 이후 구슬이 생성될 때 랜덤 확률로 사용할 수 있는 광원을 할당하고, 밝기를 올려서 활성화시켰습니다.

<figure>
  <img src="/marblie/marblie-marble.jpg" alt="구슬이 어둠 속에서 빛나는 장면" />
  <figcaption>구슬이 어둠 속에서 빛나는 장면</figcaption>
</figure>

현실적인 시뮬레이션을 위해 반발력, 질량, 마찰력 같은 구슬의 물리 속성들을 조정했습니다. 한 가지 문제는 기본 Rapier 설정에서는 곡선 트랙에 구슬이 부딛혔을 때, 미끄러지지 않고 튕겨나가는 현상이 있었습니다. 이건 시뮬레이션 타임스텝을 기본 `1/60`에서 `1/240`으로 낮춰 해결했습니다.

### 트랙

현재 총 4가지 주요 트랙이 있습니다: 직선, 곡선, 풍차, 도형 트랙.

1. **직선 트랙**

   `THREE.ExtrudeGeometry`로 만든 기본 트랙입니다. `RAPIER.ColliderDesc.cuboid` 세 개로 구성된 콜라이더를 사용해 복합 형태로 만들었습니다. 한 방향으로 회전과 스케일 조절이 가능합니다.

2. **곡선 트랙**

   사용자가 직접 곡률을 조절할 수 있는 Bezier 곡선을 기반으로 합니다. `THREE.QuadraticBezierCurve`로 곡선을 만들고, `THREE.ExtrudeGeometry`로 지오메트리를 생성했습니다. 단, 곡선을 따라 밀어내기해 지오메트리를 생성하는 이 방식은 경사(bevel)을 지원하지 않아 별도로 `THREE.ShapeGeometry`를 이용해 캡을 추가했습니다. 콜라이더는 `RAPIER.ColliderDesc.trimesh`를 사용했고, 정점 병합을 위해 `BufferGeometryUtils.mergeVertices`를 활용했습니다.

3. **풍차 트랙**

   직각으로 배치된 두 직선 트랙을 `world.createImpulseJoint`로 중심에 연결했습니다.

4. **도형 트랙**

   깔때기나 링, 원뿔 등 특수 기능은 없지만 형태에 따른 콜라이더만 필요한 트랙들입니다. 정확한 충돌이 필요한 경우엔 `RAPIER.ColliderDesc.trimesh`, 성능이 더 중요한 경우엔 `RAPIER.ColliderDesc.convexHull`을 사용했습니다. convexHull은 오목한 부분을 무시하기 때문에 간단한 충돌 처리를 제공합니다.

모든 트랙은 `THREE.Group`으로 묶어 트랜스폼 컨트롤이 용이하게 구성되어 있습니다. 예를 들어 풍차 트랙은 두 개의 `THREE.Mesh`로 이루어져 있고, 이를 하나의 그룹으로 묶으면 단일 컨트롤로 조작이 가능합니다.

<figure>
  <img
    src="/marblie/marblie-debug.jpg"
    alt="다양한 트랙의 콜라이더를 보여주는 디버그 장면"
  />
  <figcaption>다양한 트랙의 콜라이더를 보여주는 디버그 장면</figcaption>
</figure>

## 트랙 트랜스폼

사용자가 마치 냉장고 자석을 움직이듯, 트랙을 직관적으로 조작할 수 있도록 만들고 싶었습니다.. 처음엔 `THREE.TransformControls`의 동작을 참고했고, 트랙은 한 평면 위에서만 움직이도록 했습니다. 이후 회전과 스케일도 같은 UI에 통합했고, 필요한 요소들을 파악한 뒤 소스 코드를 참고하며 컨트롤을 처음부터 다시 만들었습니다.

### 컨트롤

트랙을 클릭하면 트랜스폼 핸들이 활성화됩니다. 클릭 감지는 여러 `THREE.Raycaster` 객체를 조합해 처리했습니다.

- **이동(Translation)**
  트랙의 메시 어디든 클릭 후 드래그하면 이동됩니다. 클릭 위치를 메시 중심과 오프셋하여 메쉬가 갑자기 클릭위치로 변경되지 않게 하였습니다.
- **스케일 & 회전**
  양 끝 핸들을 드래그하여 회전 및 크기 조절이 가능합니다. 회전은 핸들 움직임의 방향과 각도 차를 계산해 적용되어 핸들을 움직이는 방향으로 회전되도록 하였습니다. 스케일은 중심과 포인터 거리로 계산되며 일정 범위 내에서 제한됩니다.
- **곡선 편집**
  곡선 트랙의 경우 회전/스케일 대신 세 개의 제어점을 각각 움직일 수 있습니다. 이를 통해 곡선을 직접 수정할 수 있으며, 수정시 매 프레임마다 새로운 곡선을 기반으로 `THREE.ExtrudeGeometry`가 다시 생성되어 메쉬가 업데이트됩니다.

<figure>
  <img src="/marblie/marblie-editing.jpg" alt="직선 트랙과 곡선 트랙을 편집하는 장면" />
  <figcaption>직선 트랙과 곡선 트랙을 편집하는 장면</figcaption>
</figure>

## 추가 기능

### 구슬 타이머

3초마다 시작 지점에 구슬이 생성됩니다.

### 다크 모드

단순한 색상 반전이 아닌 장면 전체의 분위기가 바뀌도록 하였습니다. HTML 요소의 CSS 색상과 함께 조명 방향 및 밝기가 변하고, 주변광과 방향광이 줄어듭니다. 구슬과 로고의 발광 값이 높아지고, 로고 뒤에 있는 area light가 켜져 도시의 야경 느낌을 줍니다.

### 구슬 따라가기 모드

카메라가 마지막으로 생성된 구슬을 따라갑니다. 프레임마다 구슬의 위치 변화량을 카메라 위치에 더해주며, 궤도 컨트롤의 중심을 구슬로 설정해 회전도 가능합니다.

## 마무리 생각

Rapier의 WebAssembly 통합 성능이 생각보다 훨씬 좋았습니다. 특히 복잡한 trimesh에서도 물리 계산을 매끄럽게 처리해줬습니다. 트랙과의 상호작용을 애니메이션으로 살리는 과정이 재미있었고, 작은 디테일 하나하나에 신경 쓰는 재미도 컸습니다.

아직 만들 수 있는 트랙 타입이 무궁무진하다고 생각하고, 상상만으로도 기대가 됩니다. 그 과정에서 Three.js에서의 조명 최적화, Rapier 콜라이더의 성능 차이 등에 대해 더 깊이 있게 배울 수 있었습니다. 저에게는 정말 재미있고 의미 있는 실험 공간이었고, 앞으로도 계속 발전시켜나가고 싶습니다.

읽어주셔서 감사합니다. 마블리는 [여기서](http://marblie.com) 해보실 수 있고 소스코드는 [여기서](https://github.com/younghoonam/marblie) 확인하실 수 있습니다.
